# svelte-css-rune

Svelte provides an elegant way to scope styles to components, but passing styles between parent and child components can be challenging. There's no built-in mechanism for this, often leading to workarounds like declaring classes as global and carefully managing potential naming conflicts. This library introduces a simple way to pass styles between components using the `$css` rune, which is achieved with a preprocessor. It solves the problem of style conflicts and promotes better style encapsulation when working with nested components.

## Example

Child.svelte
```svelte
<script>
	let {containerClass, buttonClass} = $props();
</script>

<div class={containerClass}>
	<button class={buttonClass}></button>
</div>
```
Parent.svelte
```svelte
<script>
	import Child from "./Child.svelte"
</script>

<Child containerClass={$css("container")} buttonClass={$css("button")} />

<style>
	.container{
		background: rebeccapurple;
	}
	.button{
		color: white;
	}
</style>
```

# Install

Svelte 5 is required, but it is compatible with both rune and legacy syntaxes.

1) Add `svelte-css-rune` as devDependency. Use the appropriate command for your package manager:
	```bash
	npm install --save-dev svelte-css-rune
	```
	```
	bun add --dev svelte-css-rune
	```
	```bash
	yarn add --dev svelte-css-rune
	```
	```bash
	pnpm add -D svelte-css-rune
	```
2) Add the preprocessor to your Svelte configuration. This is usually in `svelte.config.js`/`ts`, but can also be in `rollup.config.js`/`ts` or `vite.config.js`/`ts`. SvelteKit uses a `svelte.config.js`/`ts` file. 
	```javascript
	import cssRune from "svelte-css-rune";
	export default {
		preprocess: cssRune(),
		// Rest of the config
	}
	```
	If you are using other preprocessors, such as `svelte-preprocess`, you can pass an array of preprocessors. 
	
	**The order is important**: `svelte-css-rune` should be the last one in the array."
	```javascript
	import cssRune from "svelte-css-rune";
	import preprocess from "svelte-preprocess";
	export default {
		preprocess: [preprocess(), cssRune()],
		// Rest of the config
	}
	```
3) Use the `$css` rune in your components. 

See the [Typescript](#Typescript) section for typescript support.
You can find a svelte kit example in the [example](example) folder.

# How it works and advanced usage

The `$css` rune is a function that takes a **string literal** as an argument. The rune is replaced with a unique class name that is generated by the preprocessor. This class name is unique to the file and the original name, preventing naming conflicts when passing styles between components. It modifies class names within style tags to match the generated names and utilizes the `:global` selector to make these generated classes globally accessible. It only affects classes that are referenced with the `$css` rune. Classes used both with the `$css` rune and natively (i.e., directly within the class attribute without the rune) are duplicated. This should be avoided as it results in larger bundle sizes and can potentially cause issues. The preprocessor will warn you if such an issue ever occurs.

## Usage
You can use the `$css` rune inside script tags, script module tags, and within the markup. It integrates seamlessly with all Svelte style features, including the new `clsx` integration. It's statically replaced with the generated class name. The content of the `$css` rune must be a string literal; unquoted strings are not supported. The preprocessor will issue a warning if the `$css`rune is used in an unsupported way.

```svelte
<script module>
	export const globalClassName = $css("my-class");
</script>
<script>
	let className = $css("my-class");
	let {dark, bold} = $props();
</script>

<div class={myClass}></div>

<!-- You can use it directly within the markup -->
<div class={$css("my-class")}></div>
<!-- You can combine it with native usage of the same class within the same file -->
<div class="my-class">

<!-- You can pass multiple classes at once -->
<Button class={$css("button dark")} />

<!-- Works with ternary expressions -->
<Button class={dark?$css("dark"):$css("light")}></Button>

<!-- Works with clsx syntax -->
<Button class={[dark && $css("dark"), bold && $css("bold")]}></Button>

<!-- No need to modify the style tag; it works with other preprocessors like Sass -->
<style>
	.my-class{
		color: red;
	}
	.button{
		color: blue;
	}
	.dark{
		background: black;
	}
	.light{
		background: black;
	}
	.bold{
		font-weight: bold;
	}
</style>
```

### Errors and Warnings

This preprocessor does not interfere with or disable Svelte's unused class warnings. It will produce an error if the `$css` rune is misused or references a non-existent class. Error messages are descriptive and pinpoint the exact location of the issue.

```
/example/Component.svelte

202| });
203|
204| const className = $css("i-dont-exist")
                       ^^^^^^^^^^^^^^^^^^^^
                class i-dont-exist is not defined
```


## Example Transpilation

Consider a component with mixed usage like this:

```svelte
<div class="outer">
	<Child class={$css("inner")}/> 
</div> 
<Child class={$css("child")}/>
<style>
	.outer .inner{
		color: red;
	}
	.child{
		color: blue;
	}
</style>
```

Everything works fine. This is compiled to:
```svelte
<div class="outer">
	<Child class={"inner-1oseexr"}/> 
</div> 
<Child class={"child-1oseexr"}/>
<style>
	.outer :global(.inner-1oseexr){
		color: red;
	}
	.child{
		color: blue;
	}
</style>
```
Note the random string appended to the class names. This ensures unique class names. It's generated based on the path and content of the component.

# Typescript 

This library provides full TypeScript support. It provides a global declaration for the `$css` rune. If this is not working automatically for your setup
you should reference this package in a .d.ts file in your project. The default SvelteKit app comes with src/app.d.ts. 

Simply add:

```typescript
/// <reference types="svelte-css-rune" />

```
to the top of this file.

Alternatively, you can add this package to the `types` field in your `tsconfig.json`, or add

```typescript
import type {} from "svelte-css-rune";

```
to every file where the rune is used.


# Edge Cases

### Note: The following edge case is unlikely to affect most users. It's included for completeness and transparency. If you haven't been directed here by a warning from the preprocessor, you can likely skip this section.

## Rules combining multiple classes with mixed usage

CSS rules combining multiple selectors, where more than one are used both natively by Svelte and with the `$css` rune, can lead to unintended behavior. The preprocessor will emit a warning when it detects this usage. It's recommended to use the `$css` rune consistently for all occurrences of a class within a file.


## What this issue looks like

For example, when writing a component with mixed usage like this:

```svelte
<div class="outer">
	<div class={$css("inner")}>
	</div> 
</div> 
<div class={$css("outer")}>
	<div class={$css("inner")}>
	</div> 
</div>
<style>
	.outer .inner{
		color: red;
	}
</style>
```

Everything works fine. This is compiled to:
```svelte
<div class="outer">
	<div class={"inner-1oseexr"}>
	</div> 
</div> 
<div class={"outer-1oseexr"}>
	<div class={"inner-1oseexr"}>
	</div> 
</div>
<style>
	:global(.outer-1oseexr) :global(.inner-1oseexr){
		color: red;
	}
	.outer :global(.inner-1oseexr){
		color: red;

	}
</style>
```
All classes work as expected; the rule has been duplicated to accommodate the mixed usage. This works initially because only one of the classes, `outer`, is used both with the `$css` rune and natively. If we now introduce native usage of the `inner` class:

```svelte
<div class="outer">
	<div class={$css("inner")}>
	</div> 
</div> 
<div class={$css("outer")}>
	<div class="inner">
	</div> 
</div>
<style>
	.outer .inner{
		color: red;
	}
</style>
```
### It Breaks! This is compiled to:
```svelte
<div class="outer">
	<div class={"inner-1oseexr"}>
	</div> 
</div> 
<div class={"outer-1oseexr"}>
	<div class="inner">
	</div> 
</div>
<style>
	:global(.outer-1oseexr) :global(.inner-1oseexr){
		color: red;
	}
	.outer .inner{
		color: red;
	}
</style>
```
Notice that no rule matches anymore! This issue is unlikely to occur in most codebases, as it's generally best to avoid mixing the usage of classes between $css runes and native Svelte style application. The preprocessor will warn you when this situation occurs, but the warning is over aggressive and will trigger even in cases where it's not an issue. The following code will trigger the same warning, even though it's technically working:

```svelte
<div class={$css("outer")}>
	<div class={$css("inner")}>
	</div> 
</div> 
<div class="outer">
	<div class="inner">
	</div> 
</div>
<style>
	.outer .inner{
		color: red;
	}
</style>
```
Encountering this warning is a good opportunity to refactor your code to avoid mixing the usage of classes between `$css` runes and native Svelte class application.

### How to fix it

Just wrap all usages of these classes with the `$css` rune. Creating a renamed copy of one class and replacing only native or `$css` rune references to it works, too.

## Building and Testing

You can build this library using either Node.js or Bun via the build script. It compiles to both ESM and CommonJS formats.
```bash
npm run build
```
```bash
bun run build
```
Bun is required to run the tests.
```bash
bun test
```

# Comparison to svelte-preprocess-cssmodules

[`svelte-preprocess-cssmodules`](https://github.com/micantoine/svelte-preprocess-cssmodules) can be used to archive something similar. However, its primary goal is to provide CSS Modules support, not solely a mechanism for passing classes between components.

It generates unique class names for every class within a style tag, transforming all styles in a file to use these generated names. This involves parsing and replacing a significant portion of your code, essentially replacing Svelte's built-in style handling. It also treats the `class` prop as a special, magical property, and adding other attributes requires global configuration for all components. Furthermore, it disables Svelte's unused class warnings.

`svelte-css-rune` is a significantly simpler library. It only replaces the `$css` rune and the referenced class with a unique class name, leaving other styles untouched.
It aims for simplicity and a seamless integration with the rest of the Svelte 5 syntax. It does not disable Svelte's unused class warnings.

`svelte-preprocess-cssmodules` is a great library if you require more extensive features. This library draws significant inspiration from it.

While I initially created a pull request to add this feature to `svelte-preprocess-cssmodules`, this standalone library offers greater flexibility and simplicity

# License

[MIT](https://opensource.org/licenses/MIT)
