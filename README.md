# svelte-css-rune

This library adds a simple way to pass style between components, the `$css` rune. It utilizes a preprocessor to achieve this. 


## Example
Child.svelte
```svelte
<script>
	let {containerClass, buttonClass} = $props();
</script>

<div class={containerClass}>
	<button class={buttonClass}></button>
</div>
```
Parent.svelte
```svelte
<script>
	import Child from "./Child.svelte"
</script>

<Child containerClass={$css("container")} buttonClass={$css("button")} />

<style>
	.container{
		background: rebeccapurple;
	}
	.button{
		color: white;
	}
</style>
```

# Install

Svelte 5 is required, but it works with rune and legacy syntax.

1) Add svelte-css-rune as devDependency. Use the command that fits your package manager.
	```
	npm install --save-dev svelte-css-rune
	```
	```
	bun add --dev svelte-css-rune
	```
	```
	yarn add --dev svelte-css-rune
	```
	```
	pnpm add -D svelte-css-rune
	```
2) Add the preprocessor to your svelte config. This is usually in svelte.config.js/ts, but can also be in rollup.config.js/ts or vite.config.js/ts. SvelteKit uses a svelte.config.js/ts file. 
	```javascript
	import cssRune from "svelte-css-rune";
	export default {
		preprocess: cssRune(),
		// Rest of the config
	}
	```
	If you are using other preprocessors such as `svelte-preprocess` you can add the rune to the array of preprocessors. The order of the preprocessors is important. The rune should be the last preprocessor in the array. 
	```javascript
	import cssRune from "svelte-css-rune";
	import preprocess from "svelte-preprocess";
	export default {
		preprocess: [preprocess(), cssRune()],
		// Rest of the config
	}
	```
3) Use the $css rune in your components. 

See the [Typescript](#Typescript) section for typescript support.

# How it works and advanced usage

The $css rune is a function that takes a string as an argument. The rune is replaced with a unique class name that is generated by the preprocessor. This class name is unique to the file and the string passed to the rune. This allows you to pass styles between components without worrying about naming conflicts. It modifies the class names in the style tags to match the generated class names and uses :global selector to make the generated classes global. It only affects classes that are used with the rune. Classes that are used with the rune and natively are duplicated. This should be avoided, as it leds to bigger bundles and can cause issues. The preprocessor will warn you should you ever run into such an issue.

## Usage
You can use the $css rune inside of script tags, script module tags and markup. It works with all svelte style features, like the new clsx integration. Its statically replaced with the generated classname. The content of the rune must be a string. Unquoted strings are not supported. The preprocessor will warn you use the rune in a way that is not supported.  

```svelte
<script module>
	export const globalClassName = $css("my-class");
</script>
<script>
	let className = $css("my-class");
	let {dark, bold} = $props();
</script>

<div class={$css("my-class")}></div>
<!-- You can mix it with native usage of the same class in the same file -->
<div class="my-class">

<!-- You can pass multiple classes at once -->
<Button class={$css("button dark")} />
<div class={myClass}></div>
<Button class={[dark && $css("dark"), bold && $css("bold")]}></Button>

<!-- No need to modify the style tag -->
<style>
	.my-class{
		color: red;
	}
	.button{
		color: blue;
	}
	.dark{
		background: black;
	}
	.bold{
		font-weight: bold;
	}
</style>
```

### Errors and Warnings

This preprocessor does not break or disable sveltes unused class warnings. If the rune is misused or references a class that does not exist. Errors are pretty and point you to the exact location of the issue. 
```
/example/Component.svelte

202| });
203|
204| const className = $css("i-dont-exist")
                       ^^^^^^^^^^^^^^^^^^^^
                class i-dont-exist is not defined
```


## Example Transpilation


When writing a component with mixed usage like this:
```svelte
<div class="outer">
	<Child class={$css("inner")}/> 
</div> 
<Child class={$css("child")}/>
<style>
	.outer .inner{
		color: red;
	}
	.child{
		color: blue;
	}
</style>
```

Everything works fine. This is compiled to:
```svelte
<div class="outer">
	<Child class={"inner-1oseexr"}/> 
</div> 
<Child class={"child-1oseexr"}/>
<style>
	.outer-1oseexr :global(.inner-1oseexr){
		color: red;
	}
	.child{
		color: blue;
	}
</style>
```
Notice the random string added to the class names. This is to ensure that the class names are unique. Its generated based on the path and content of the component.

# Typescript 

This library has full typescript support. It provides a global declaration for the $css rune. If this is not working automatically for your setup
you should reference this package in a .d.ts file in your project. The default SvelteKit app comes with src/app.d.ts. Just add:
```typescript
/// <reference types="svelte-css-rune" />

```
to the top of this file.

Alternatively you can also add this package to the types field in your package json, or add 
```typescript
import type {} from "svelte-css-rune";

```
to every file that uses the rune.


# Limitations

### The preprocessor will detect this and warn you. If you are not send here by the warning you can ignore this section because you will probably not run into this.

## Rules combining multiple classes with mixed usage

CSS rules combining multiple selectors that are used natively by svelte and with the $css rune can lead to unintended behavior. The preprocessor will emit a warning when it detects this usage. Its best to use the $css rune on all occurrences of a class in a file. 


## What this issue looks like

When writing a component with mixed usage like this:
```svelte
<div class="outer">
	<div class={$css("inner")}>
	</div> 
</div> 
<div class={$css("outer")}>
	<div class={$css("inner")}>
	</div> 
</div>
<style>
	.outer .inner{
		color: red;
	}
</style>
```

Everything works fine. This is compiled to:
```svelte
<div class="outer">
	<div class={"inner-1oseexr"}>
	</div> 
</div> 
<div class={"outer-1oseexr"}>
	<div class={"inner-1oseexr"}>
	</div> 
</div>
<style>
	:global(.outer-1oseexr) :global(.inner-1oseexr){
		color: red;
	}
	.outer :global(.inner-1oseexr){
		color: red;

	}
</style>
```
All classes work as expected, the rule has been duplicated to accommodate the mixed usage. This works because only one of the classes, outer, is used with the rune and native. This brakes if we add native usage of the inner class:

```svelte
<div class="outer">
	<div class={$css("inner")}>
	</div> 
</div> 
<div class={$css("outer")}>
	<div class="inner">
	</div> 
</div>
<style>
	.outer .inner{
		color: red;
	}
</style>
```
### Breaks! This is compiled to:
```svelte
<div class="outer">
	<div class={"inner-1oseexr"}>
	</div> 
</div> 
<div class={"outer-1oseexr"}>
	<div class="inner">
	</div> 
</div>
<style>
	:global(.outer-1oseexr) :global(.inner-1oseexr){
		color: red;
	}
	.outer .inner{
		color: red;
	}
</style>
```
Notice how there is no rule that matches anymore! This issue should not occur in most codebases, as its better to not mix usage of classes between runes and native. The preprocessor will warn you whenever this occurs, but the warning is not very specific. 

```svelte
<div class={$css("outer")}>
	<div class={$css("inner")}>
	</div> 
</div> 
<div class="outer">
	<div class="inner">
	</div> 
</div>
<style>
	.outer .inner{
		color: red;
	}
</style>
```
Will cause the same warning, but is completely fine. Its a good idea to avoid this anyway as this can easily lead to the same issue later. 

### How to fix it

Just wrap all usages of these classes with the $css rune. Creating a renamed copy of one class and replacing only native or rune references to it works to.

## building and testing

You should be able to build this library with node or bun via the build script. It compiles to ESM and CommonJS. Bun is required to run the tests.

# Comparison to svelte-preprocess-cssmodules

svelte-preprocess-cssmodules can be used to archive something similar. But its main goal is to provide css modules support, not just a way to pass classes between components.

It generates unique class names for each class in a style tag. It transforms all styles in a file to use these generated class names and parses/replaces much more of your code. This library mostly replaces sveltes style handling. It also treats the class prop as a magical special prop. Others can only be added globally for all components. It disables sveltes unused class warnings.

Svelte-css-rune is a much simpler library. It only replaces the $css rune and the referenced class with a unique class name. It does not touch other style at all. 
It aims to be simpler and feel like the rest of svelte 5 syntax. It does not disable sveltes unused class warnings.

svelte-preprocess-cssmodules is a great library if you need more features. This library is heavily inspired by it. 

I created a pull request to add a this feature to svelte-preprocess-cssmodules, but this standalone library is more flexible and a lot simpler.